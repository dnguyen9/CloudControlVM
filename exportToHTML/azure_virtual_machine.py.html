<html>
<head>
<title>azure_virtual_machine.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(0,0,128); font-weight: bold; }
.s3 { color: rgb(0,128,0); font-weight: bold; }
.s4 { color: rgb(0,0,255); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
azure_virtual_machine.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0"># Copyright 2014 PerfKitBenchmarker Authors. All rights reserved.</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><span class="s1"> 
</span><span class="s0"># you may not use this file except in compliance with the License.</span><span class="s1"> 
</span><span class="s0"># You may obtain a copy of the License at</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0">#   http://www.apache.org/licenses/LICENSE-2.0</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0"># Unless required by applicable law or agreed to in writing, software</span><span class="s1"> 
</span><span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><span class="s1"> 
</span><span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><span class="s1"> 
</span><span class="s0"># See the License for the specific language governing permissions and</span><span class="s1"> 
</span><span class="s0"># limitations under the License.</span><span class="s1"> 
 
</span><span class="s0">&quot;&quot;&quot;Class to represent an Azure Virtual Machine object. 
 
Zones: 
run 'azure vm location list' 
Machine Types: 
http://msdn.microsoft.com/en-us/library/azure/dn197896.aspx 
Images: 
run 'azure vm image list' 
 
All VM specifics are self-contained and the class provides methods to 
operate on the VM: boot, shutdown, etc. 
&quot;&quot;&quot;</span><span class="s1"> 
 
</span><span class="s2">import </span><span class="s1">json 
</span><span class="s2">import </span><span class="s1">re 
</span><span class="s2">import </span><span class="s1">threading 
 
</span><span class="s2">from </span><span class="s1">perfkitbenchmarker </span><span class="s2">import </span><span class="s1">disk 
</span><span class="s2">from </span><span class="s1">perfkitbenchmarker </span><span class="s2">import </span><span class="s1">errors 
</span><span class="s2">from </span><span class="s1">perfkitbenchmarker </span><span class="s2">import </span><span class="s1">flags 
</span><span class="s2">from </span><span class="s1">perfkitbenchmarker </span><span class="s2">import </span><span class="s1">linux_virtual_machine 
</span><span class="s2">from </span><span class="s1">perfkitbenchmarker </span><span class="s2">import </span><span class="s1">resource 
</span><span class="s2">from </span><span class="s1">perfkitbenchmarker </span><span class="s2">import </span><span class="s1">virtual_machine 
</span><span class="s2">from </span><span class="s1">perfkitbenchmarker </span><span class="s2">import </span><span class="s1">vm_util 
</span><span class="s2">from </span><span class="s1">perfkitbenchmarker </span><span class="s2">import </span><span class="s1">windows_virtual_machine 
</span><span class="s2">from </span><span class="s1">perfkitbenchmarker.providers.azure </span><span class="s2">import </span><span class="s1">azure_disk 
</span><span class="s2">from </span><span class="s1">perfkitbenchmarker.providers.azure </span><span class="s2">import </span><span class="s1">azure_network 
</span><span class="s2">from </span><span class="s1">perfkitbenchmarker </span><span class="s2">import </span><span class="s1">providers 
 
FLAGS = flags.FLAGS 
 
AZURE_PATH = </span><span class="s3">'azure'</span><span class="s1"> 
 
</span><span class="s0"># Dict mapping OS_TYPE string to re.RegexObject. The RegexObject matches the</span><span class="s1"> 
</span><span class="s0"># names of images for that OS type while extracting integer components of the</span><span class="s1"> 
</span><span class="s0"># version and date from the image name in order of decreasing priority.</span><span class="s1"> 
_default_image_patterns = {} 
</span><span class="s0"># Lock-protected dict mapping OS_TYPE string to default image name string.</span><span class="s1"> 
_default_images_lock = threading.Lock() 
_default_images = None 
 
 
</span><span class="s2">def </span><span class="s1">_GetDefaultImagesFromAzure(): 
  </span><span class="s0">&quot;&quot;&quot;Gets the default images for each OS type in _default_image_patterns. 
 
  Returns: 
    dict mapping OS_TYPE string to default image name string. 
 
  Raises: 
    errors.Error: If unable to get the default image for an OS_TYPE. 
  &quot;&quot;&quot;</span><span class="s1"> 
  list_images_cmd = [AZURE_PATH, </span><span class="s3">'vm'</span><span class="s1">, </span><span class="s3">'image'</span><span class="s1">, </span><span class="s3">'list'</span><span class="s1">, </span><span class="s3">'--json'</span><span class="s1">] 
  stdout, _ = vm_util.IssueRetryableCommand(list_images_cmd) 
  azure_vm_image_list = json.loads(stdout) 
  images_by_os_type = {} 
  </span><span class="s2">for </span><span class="s1">image </span><span class="s2">in </span><span class="s1">azure_vm_image_list: 
    </span><span class="s2">for </span><span class="s1">os_type, pattern </span><span class="s2">in </span><span class="s1">_default_image_patterns.iteritems(): 
      match = pattern.match(image[</span><span class="s3">'name'</span><span class="s1">]) 
      </span><span class="s2">if </span><span class="s1">match: 
        image_name_fields = tuple(None </span><span class="s2">if </span><span class="s1">g </span><span class="s2">is </span><span class="s1">None </span><span class="s2">else </span><span class="s1">int(g) 
                                  </span><span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">match.groups()) 
        os_images = images_by_os_type.setdefault(os_type, {}) 
        os_images[image_name_fields] = match.group(</span><span class="s4">0</span><span class="s1">) 
  default_images = {} 
  </span><span class="s2">for </span><span class="s1">os_type, pattern </span><span class="s2">in </span><span class="s1">_default_image_patterns.iteritems(): 
    os_images = images_by_os_type.get(os_type) 
    </span><span class="s2">if not </span><span class="s1">os_images: 
      </span><span class="s2">raise </span><span class="s1">errors.Error( 
          </span><span class="s3">'Unable to get Azure default {0} image. No image names match '</span><span class="s1"> 
          </span><span class="s3">'{1}'</span><span class="s1">.format(os_type, pattern.pattern)) 
    default_images[os_type] = os_images[max(os_images)] 
  </span><span class="s2">return </span><span class="s1">default_images 
 
 
</span><span class="s2">def </span><span class="s1">_GetDefaultImage(os_type): 
  </span><span class="s0">&quot;&quot;&quot;Gets the default image name for a given VM operating system. 
 
  Args: 
    os_type: string. VM operating system. 
 
  Returns: 
    string. Name of the image. 
  &quot;&quot;&quot;</span><span class="s1"> 
  </span><span class="s2">global </span><span class="s1">_default_images 
  </span><span class="s2">if </span><span class="s1">_default_images </span><span class="s2">is </span><span class="s1">None: 
    </span><span class="s2">with </span><span class="s1">_default_images_lock: 
      </span><span class="s2">if </span><span class="s1">_default_images </span><span class="s2">is </span><span class="s1">None: 
        _default_images = _GetDefaultImagesFromAzure() 
  </span><span class="s2">return </span><span class="s1">_default_images[os_type] 
 
 
</span><span class="s2">class </span><span class="s1">AzureService(resource.BaseResource): 
  </span><span class="s0">&quot;&quot;&quot;Object representing an Azure Service.&quot;&quot;&quot;</span><span class="s1"> 
 
  </span><span class="s2">def </span><span class="s1">__init__(self, name, zone): 
    super(AzureService, self).__init__() 
    self.name = name 
    self.zone = zone 
 
  </span><span class="s2">def </span><span class="s1">_Create(self): 
    </span><span class="s0">&quot;&quot;&quot;Creates the Azure service.&quot;&quot;&quot;</span><span class="s1"> 
    create_cmd = [AZURE_PATH, 
                  </span><span class="s3">'service'</span><span class="s1">, 
                  </span><span class="s3">'create'</span><span class="s1">, 
                  </span><span class="s3">'--location=%s' </span><span class="s1">% self.zone, 
                  self.name] 
    vm_util.IssueCommand(create_cmd) 
 
  </span><span class="s2">def </span><span class="s1">_Delete(self): 
    </span><span class="s0">&quot;&quot;&quot;Deletes the Azure service.&quot;&quot;&quot;</span><span class="s1"> 
    delete_cmd = [AZURE_PATH, 
                  </span><span class="s3">'service'</span><span class="s1">, 
                  </span><span class="s3">'delete'</span><span class="s1">, 
                  </span><span class="s3">'--quiet'</span><span class="s1">, 
                  self.name] 
    vm_util.IssueCommand(delete_cmd) 
 
  </span><span class="s2">def </span><span class="s1">_Exists(self): 
    </span><span class="s0">&quot;&quot;&quot;Returns true if the service exists.&quot;&quot;&quot;</span><span class="s1"> 
    show_cmd = [AZURE_PATH, 
                </span><span class="s3">'service'</span><span class="s1">, 
                </span><span class="s3">'show'</span><span class="s1">, 
                </span><span class="s3">'--json'</span><span class="s1">, 
                self.name] 
    stdout, _, _ = vm_util.IssueCommand(show_cmd, suppress_warning=True) 
    </span><span class="s2">try</span><span class="s1">: 
      json.loads(stdout) 
    </span><span class="s2">except </span><span class="s1">ValueError: 
      </span><span class="s2">return </span><span class="s1">False 
    </span><span class="s2">return </span><span class="s1">True 
 
 
</span><span class="s2">class </span><span class="s1">AzureVirtualMachineMetaClass(virtual_machine.AutoRegisterVmMeta): 
  </span><span class="s0">&quot;&quot;&quot;Metaclass for AzureVirtualMachine. 
 
  Registers default image pattern for each operating system. 
  &quot;&quot;&quot;</span><span class="s1"> 
 
  </span><span class="s2">def </span><span class="s1">__init__(cls, name, bases, dct): 
    super(AzureVirtualMachineMetaClass, cls).__init__(name, bases, dct) 
    </span><span class="s2">if </span><span class="s1">hasattr(cls, </span><span class="s3">'OS_TYPE'</span><span class="s1">): 
      </span><span class="s2">assert </span><span class="s1">cls.OS_TYPE, </span><span class="s3">'{0} did not override OS_TYPE'</span><span class="s1">.format(cls.__name__) 
      </span><span class="s2">assert </span><span class="s1">cls.DEFAULT_IMAGE_PATTERN, ( 
          </span><span class="s3">'{0} did not override DEFAULT_IMAGE_PATTERN'</span><span class="s1">.format(cls.__name__)) 
      _default_image_patterns[cls.OS_TYPE] = cls.DEFAULT_IMAGE_PATTERN 
 
 
</span><span class="s2">class </span><span class="s1">AzureVirtualMachine(virtual_machine.BaseVirtualMachine): 
  </span><span class="s0">&quot;&quot;&quot;Object representing an Azure Virtual Machine.&quot;&quot;&quot;</span><span class="s1"> 
 
  __metaclass__ = AzureVirtualMachineMetaClass 
  CLOUD = providers.AZURE 
  </span><span class="s0"># Subclasses should override the default image pattern.</span><span class="s1"> 
  DEFAULT_IMAGE_PATTERN = None 
 
  </span><span class="s2">def </span><span class="s1">__init__(self, vm_spec): 
    </span><span class="s0">&quot;&quot;&quot;Initialize a Azure virtual machine. 
 
    Args: 
      vm_spec: virtual_machine.BaseVirtualMachineSpec object of the vm. 
    &quot;&quot;&quot;</span><span class="s1"> 
    super(AzureVirtualMachine, self).__init__(vm_spec) 
    self.network = azure_network.AzureNetwork.GetNetwork(self) 
    self.firewall = azure_network.AzureFirewall.GetFirewall() 
    self.service = AzureService(self.name, self.zone) 
    disk_spec = disk.BaseDiskSpec() 
    self.os_disk = azure_disk.AzureDisk(disk_spec, self.name, self.machine_type) 
    self.max_local_disks = </span><span class="s4">1</span><span class="s1"> 
 
  </span><span class="s2">def </span><span class="s1">_CreateDependencies(self): 
    </span><span class="s0">&quot;&quot;&quot;Create VM dependencies.&quot;&quot;&quot;</span><span class="s1"> 
    self.service.Create() 
    </span><span class="s0"># _GetDefaultImage may call the Azure CLI.</span><span class="s1"> 
    self.image = self.image </span><span class="s2">or </span><span class="s1">_GetDefaultImage(self.OS_TYPE) 
 
  </span><span class="s2">def </span><span class="s1">_DeleteDependencies(self): 
    </span><span class="s0">&quot;&quot;&quot;Delete VM dependencies.&quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">self.os_disk.name: 
      self.os_disk.Delete() 
    self.service.Delete() 
 
  </span><span class="s2">def </span><span class="s1">_Create(self): 
    create_cmd = [AZURE_PATH, 
                  </span><span class="s3">'vm'</span><span class="s1">, 
                  </span><span class="s3">'create'</span><span class="s1">, 
                  </span><span class="s3">'--location=%s' </span><span class="s1">% self.zone, 
                  </span><span class="s3">'--virtual-network-name=%s' </span><span class="s1">% self.network.vnet.name, 
                  </span><span class="s3">'--vm-size=%s' </span><span class="s1">% self.machine_type, 
                  self.name, 
                  self.image, 
                  self.user_name] 
    </span><span class="s2">if </span><span class="s1">self.password: 
      create_cmd.append(self.password) 
    </span><span class="s2">else</span><span class="s1">: 
      create_cmd.extend([</span><span class="s3">'--ssh=%d' </span><span class="s1">% self.ssh_port, 
                         </span><span class="s3">'--ssh-cert=%s' </span><span class="s1">% vm_util.GetCertPath(), 
                         </span><span class="s3">'--no-ssh-password'</span><span class="s1">]) 
    vm_util.IssueCommand(create_cmd) 
 
  </span><span class="s2">def </span><span class="s1">_Delete(self): 
    delete_cmd = [AZURE_PATH, 
                  </span><span class="s3">'vm'</span><span class="s1">, 
                  </span><span class="s3">'delete'</span><span class="s1">, 
                  </span><span class="s3">'--quiet'</span><span class="s1">, 
                  self.name] 
    vm_util.IssueCommand(delete_cmd) 
 
  </span><span class="s2">def </span><span class="s1">_Exists(self): 
    </span><span class="s0">&quot;&quot;&quot;Returns true if the VM exists and attempts to get some data.&quot;&quot;&quot;</span><span class="s1"> 
    show_cmd = [AZURE_PATH, 
                </span><span class="s3">'vm'</span><span class="s1">, 
                </span><span class="s3">'show'</span><span class="s1">, 
                </span><span class="s3">'--json'</span><span class="s1">, 
                self.name] 
    stdout, _, _ = vm_util.IssueCommand(show_cmd, suppress_warning=True) 
    </span><span class="s2">try</span><span class="s1">: 
      json.loads(stdout) 
    </span><span class="s2">except </span><span class="s1">ValueError: 
      </span><span class="s2">return </span><span class="s1">False 
    </span><span class="s2">return </span><span class="s1">True 
 
  @vm_util.Retry() 
  </span><span class="s2">def </span><span class="s1">_PostCreate(self): 
    </span><span class="s0">&quot;&quot;&quot;Get VM data.&quot;&quot;&quot;</span><span class="s1"> 
    show_cmd = [AZURE_PATH, 
                </span><span class="s3">'vm'</span><span class="s1">, 
                </span><span class="s3">'show'</span><span class="s1">, 
                </span><span class="s3">'--json'</span><span class="s1">, 
                self.name] 
    stdout, _, _ = vm_util.IssueCommand(show_cmd) 
    response = json.loads(stdout) 
    self.os_disk.name = response[</span><span class="s3">'OSDisk'</span><span class="s1">][</span><span class="s3">'name'</span><span class="s1">] 
    self.os_disk.created = True 
    self.internal_ip = response[</span><span class="s3">'IPAddress'</span><span class="s1">] 
    self.ip_address = response[</span><span class="s3">'VirtualIPAddresses'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][</span><span class="s3">'address'</span><span class="s1">] 
 
  </span><span class="s2">def </span><span class="s1">CreateScratchDisk(self, disk_spec): 
    </span><span class="s0">&quot;&quot;&quot;Create a VM's scratch disk. 
 
    Args: 
      disk_spec: virtual_machine.BaseDiskSpec object of the disk. 
    &quot;&quot;&quot;</span><span class="s1"> 
    disks = [] 
 
    </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">xrange(disk_spec.num_striped_disks): 
      data_disk = azure_disk.AzureDisk(disk_spec, self.name, self.machine_type) 
      </span><span class="s2">if </span><span class="s1">disk_spec.disk_type == disk.LOCAL: 
        </span><span class="s0"># Local disk numbers start at 1 (0 is the system disk).</span><span class="s1"> 
        data_disk.disk_number = self.local_disk_counter + </span><span class="s4">1</span><span class="s1"> 
        self.local_disk_counter += </span><span class="s4">1</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">self.local_disk_counter &gt; self.max_local_disks: 
          </span><span class="s2">raise </span><span class="s1">errors.Error(</span><span class="s3">'Not enough local disks.'</span><span class="s1">) 
      </span><span class="s2">else</span><span class="s1">: 
        </span><span class="s0"># Remote disk numbers start at 1 + max_local disks (0 is the system disk</span><span class="s1"> 
        </span><span class="s0"># and local disks occupy [1, max_local_disks]).</span><span class="s1"> 
        data_disk.disk_number = (self.remote_disk_counter + 
                                 </span><span class="s4">1 </span><span class="s1">+ self.max_local_disks) 
        self.remote_disk_counter += </span><span class="s4">1</span><span class="s1"> 
      disks.append(data_disk) 
 
    self._CreateScratchDiskFromDisks(disk_spec, disks) 
 
  </span><span class="s2">def </span><span class="s1">GetLocalDisks(self): 
    </span><span class="s0">&quot;&quot;&quot;Returns a list of local disks on the VM. 
 
    Returns: 
      A list of strings, where each string is the absolute path to the local 
          disks on the VM (e.g. '/dev/sdb'). 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">[</span><span class="s3">'/dev/sdb'</span><span class="s1">] 
 
 
</span><span class="s2">class </span><span class="s1">DebianBasedAzureVirtualMachine(AzureVirtualMachine, 
                                     linux_virtual_machine.DebianMixin): 
 
  </span><span class="s0"># Example: ('b39f27a8b8c64d52b05eac6a62ebad85__Ubuntu-'</span><span class="s1"> 
  </span><span class="s0">#           '14_04_3-LTS-amd64-server-20150908-en-us-30GB')</span><span class="s1"> 
  DEFAULT_IMAGE_PATTERN = re.compile( 
      </span><span class="s3">r'b39f27a8b8c64d52b05eac6a62ebad85__Ubuntu-14_04'</span><span class="s1"> 
      </span><span class="s3">r'(?:_([0-9]+))?-LTS-amd64-server-([0-9]+)(?:[.]([0-9]+))?-en-us-30GB'</span><span class="s1">) 
 
 
</span><span class="s2">class </span><span class="s1">RhelBasedAzureVirtualMachine(AzureVirtualMachine, 
                                   linux_virtual_machine.RhelMixin): 
 
  </span><span class="s0"># Example: ('0b11de9248dd4d87b18621318e037d37__RightImage-'</span><span class="s1"> 
  </span><span class="s0">#           'CentOS-7.0-x64-v14.2.1')</span><span class="s1"> 
  DEFAULT_IMAGE_PATTERN = re.compile( 
      </span><span class="s3">r'0b11de9248dd4d87b18621318e037d37__RightImage-CentOS-7[.]([0-9]+)-x64-'</span><span class="s1"> 
      </span><span class="s3">r'v([0-9]+)(?:[.]([0-9]+))?(?:[.]([0-9]+))?(?:[.]([0-9]+))?'</span><span class="s1">) 
 
 
</span><span class="s2">class </span><span class="s1">WindowsAzureVirtualMachine(AzureVirtualMachine, 
                                 windows_virtual_machine.WindowsMixin): 
 
  </span><span class="s0"># Example: ('a699494373c04fc0bc8f2bb1389d6106__Windows-Server'</span><span class="s1"> 
  </span><span class="s0">#           '-2012-R2-201505.01-en.us-127GB.vhd')</span><span class="s1"> 
  DEFAULT_IMAGE_PATTERN = re.compile( 
      </span><span class="s3">r'a699494373c04fc0bc8f2bb1389d6106__Windows-Server'</span><span class="s1"> 
      </span><span class="s3">r'-2012-R2-([0-9]+)(?:[.]([0-9]+))?-en.us-127GB.vhd'</span><span class="s1">) 
 
  </span><span class="s2">def </span><span class="s1">__init__(self, vm_spec): 
    super(WindowsAzureVirtualMachine, self).__init__(vm_spec) 
    self.user_name = self.name 
    self.password = vm_util.GenerateRandomWindowsPassword() 
 
  </span><span class="s2">def </span><span class="s1">_PostCreate(self): 
    super(WindowsAzureVirtualMachine, self)._PostCreate() 
    config_dict = {</span><span class="s3">'commandToExecute'</span><span class="s1">: windows_virtual_machine.STARTUP_SCRIPT} 
    config = json.dumps(config_dict) 
    set_extension_command = [AZURE_PATH, 
                             </span><span class="s3">'vm'</span><span class="s1">, 
                             </span><span class="s3">'extension'</span><span class="s1">, 
                             </span><span class="s3">'set'</span><span class="s1">, 
                             self.name, 
                             </span><span class="s3">'CustomScriptExtension'</span><span class="s1">, 
                             </span><span class="s3">'Microsoft.Compute'</span><span class="s1">, 
                             </span><span class="s3">'1.4'</span><span class="s1">, 
                             </span><span class="s3">'--public-config=%s' </span><span class="s1">% config] 
    vm_util.IssueRetryableCommand(set_extension_command) 
</span></pre>
</body>
</html>